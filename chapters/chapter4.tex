\section{Opis działania aplikacji}
W tej sekcji są przedstawiono przetestowane miejsca implementacji. Wymienione są najważniejsze funkcjonalności, które zostały napisane w rozdziale \ref{ideal_solution}. Każda z osób miała za zadanie przetestować daną funkcjonalność.

W tej sekcji znalazły się następujące funkcjonalności:
\begin{enumerate}
  \item Logowanie i rejestracja użytkownika.
  \item Dodawanie, edycja i usuwanie postów.
  \item Edycja profilu użytkownika.
  \item Weryfikacja maila użytkownika.
  \item Wyświetlanie listy postów.
  \item Sortowanie i wyświetlanie telefonów.
  \item Sortowanie i wyświetlanie producentów.
  \item Porównanie trzech telefonów.
\end{enumerate}

\subsection{Logowanie i rejestracja użytkownika}
Aby móc zalogować się na stronę, należy posiadać przygotowany adres email. Następnie przechodzimy do ekranu logowania, za pomocą menu w prawym górnym rogu.

Na rysunku \ref{login_menu} przedstawiono przycisk umożliwiający przejście do ekranu logowania.
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.47]{tests/login-register/Login-button.png}
  \caption{Przycisk odpowiedzialny za przejście do ekranu logowania.}
  \label{login_menu}
\end{figure}
Następnie jesteśmy przenoszeni na ekran, na którym możemy się zalogować. Strona logowania została podzielona na dwie sekcje. Jedna z nich jest odpowiedzialna za logowanie. W tej sekcji znajduje się formularz, gdzie należy wpisać adres email oraz hasło. Dodatkowo umieszczono także sekcję rejestracji, gdzie można wpisać email oraz hasło dla nowego użytkownika. Na rysunku \ref{login_page} zostały przedstawione obie sekcje.
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.47]{tests/login-register/login-page.png}
  \caption{Strona logowania oraz rejestracji}
  \label{login_page}
\end{figure}
Aplikacja informuje użytkownika o wprowadzeniu nieprawidłowych danych. Aby poprawnie się zalogować, należy wpisać prawidłowe hasło. Aby móc się zarejestrować, należy wpisać adres email, który nie jest już zarejestrowany w bazie danych oraz hasło, które powinno zawierać przynajmniej 8 znaków, małe i duże litery, cyfry oraz znak specjalny. Po poprawnym zalogowaniu użytkownik jest przenoszony na stronę główną. 

Na rysunku \ref{login_success} przedstawiono przykład poprawnego przekierowania na stronę główną po zalogowaniu. 
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.47]{tests/login-register/login-sucessful.png}
  \caption{Przykład poprawnego przekierowania na stronę główną po zalogowaniu.}
  \label{login_success}
\end{figure}
Dodatkowo jeżeli użytkownik posiada zdjęcie profilowe, jest ono wyświetlane w prawym górnym rogu strony. Do zdjęcia jest również dodany przycisk, który pozwala na przejście do profilu użytkownika.

W przypadku rejestracji jeżeli użytkownik wpisze poprawne, dane zostaje przeniesiony na stronę rejestracji. Ta strona zawiera także dodatkowe informacje, które użytkownik może wprowadzić. Są to informację na temat nazwy użytkownika oraz zdjęcia profilowego.

Na rysunku \ref{register_page} przedstawiono formularz rejestracji.
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.47]{tests/login-register/register-form.png}
  \caption{Formularz rejestracji}
  \label{register_page}
\end{figure}
Po poprawnej rejestracji użytkownik jest przenoszony na stronę główną. Dodatkowo użytkownik jest informowany za pomocą powiadomienia o poprawnym zarejestrowaniu wraz z nową nazwą użytkownika. 

Na rysunku \ref{success_register} przedstawiono przykład poprawnego przekierowania po udanej rejestracji.
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.45]{tests/login-register/register-success.png}
  \caption{Przykład poprawnego przekierowania po udanej rejestracji.}
  \label{success_register}
\end{figure}
W przypadku napotkanych problemów podczas, użytkownik jest informowanych o tych w błędach za pomocą powiadomień. Wszystkie powiadomienia są wyświetlane w prawym dolnym rogu. W zależności od rodzaju powiadomienia są one rozróżnione za pomocą kolorów. Na rysunku \ref{register_error} przedstawiono przykład błędnego wprowadzenia danych.
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.7]{tests/login-register/register-error.png}
  \caption{Błąd wyświetlany w przypadku błędu rejestracji.}
  \label{register_error}
\end{figure}
Użytkownik jest informowany o tym błędach w formie podświetlenia danego pola formularza. Jeżeli wartość danej pola jest niepoprawna, to zostanie ona podświetlona na czerwono. Powoduje to zablokowanie przycisku uniemożliwiając możliwość zalogowania się na stronę.

Na rysunku \ref{login_error} przedstawiono przykład błędnego wprowadzenia danych.
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.47]{tests/login-register/register-not-valid.png}
  \caption{Przykład błędnego wprowadzenia danych}
  \label{login_error}
\end{figure}

\subsection{Dodawanie, edycja i usuwanie postów}
Aby móc dodać post użytkownik musi być zalogowany. Dodawanie postów odbywa się po kliknięciu przycisku dodaj post, użytkownik zostaje przekierowany na stronę dodawania posta. Przycisk ten pozostaje niewidoczny, dopóki użytkownik nie będzie zalogowany. Na rysunku \ref{add_post} przedstawiono stronę forum skąd można przejść do podstrony dodania posta.
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.47]{tests/add-edit-delete-posts/add-post.png}
  \caption{Strona forum z możliwością do dodawania posta}
  \label{add_post}
\end{figure}
Strona zawiera kilka rodzajów wpisów, które można stworzyć na stronie. W aplikacji występują trzy rodzaje postów: 
\begin{enumerate}
  \item \textit{question} - użytkownik może zadać pytanie dotyczące telefonów, a inni użytkownicy mogą na nie odpowiedzieć.
  \item \textit{discussion} - użytkownik może stworzyć dyskusję na temat telefonów, gdzie inni użytkownicy mogą się wypowiedzieć na temat dyskusji.
  \item \textit{listing} - użytkownik może wystawić telefon w celu sprzedaży bądź też wyceny danego telefonu. Inni użytkownicy mogą ocenić telefon oraz zaproponować cenę.
\end{enumerate}
Na rysunku \ref{add_question_page} przedstawiono stronę dodawania wpisu typu \textit{question}.
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.47]{tests/add-edit-delete-posts/create-question.png}
  \caption{Strona dodawania posta - \textit{question}}
  \label{add_question_page}
\end{figure}
Na rysunku \ref{add_discussion_post} przedstawiono stronę dodawania wpisu typu \textit{discussion}.
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.47]{tests/add-edit-delete-posts/create-discussion.png}
  \caption{Strona dodawania posta - \textit{discussion}}
  \label{add_discussion_post}
\end{figure}
Na rysunku \ref{add_listing_post} przedstawiono stronę dodawania wpisu typu \textit{listing}.
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.47]{tests/add-edit-delete-posts/create-listing.png}
  \caption{Strona dodawania posta - \textit{listing}}
  \label{add_listing_post}
\end{figure}
Na rysunkach \ref{add_question_page}, \ref{add_discussion_post} oraz \ref{add_listing_post} przedstawiono wyświetlanie błędów w przypadku niepoprawnego wprowadzenia danych. Można także zauważyć, że jeżeli występują błędy w formularzu, to przycisk dodawania posta jest zablokowany. Po wprowadzeniu poprawnych danych przycisk zostaje odblokowany. Na rysunku \ref{add_valid_post} przedstawiono poprawnie wypełniony formularz dodawania posta.
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.47]{tests/add-edit-delete-posts/create-post-valid.png}
  \caption{Strona dodawania posta - poprawna walidacja pól}
  \label{add_valid_post}
\end{figure}
Po pomyślnym dodaniu posta użytkownik zostaje przeniesiony na stronę ze swoimi postami. Na rysunku \ref{add_post_success} przedstawiono pomyślne dodania posta.
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.35]{tests/add-edit-delete-posts/successful-post-creation.png}
  \caption{Strona z postami użytkownika po dodaniu nowego posta}
  \label{add_post_success}
\end{figure}
Aby zmodyfikować post, należy przejść na stronę z postami użytkownika i kliknąć przycisk \textit{Edit}. Aby usunąć post, należy przejść na stronę z postami użytkownika i kliknąć przycisk \textit{Delete}. Na rysunku \ref{edit_post} przedstawiono stronę edycji posta. Aby zmodyfikować, należy kliknąć przycisk \textit{Update post}. 
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.46]{tests/add-edit-delete-posts/editting-post.png}
  \caption{Strona edycji posta}
  \label{edit_post}
\end{figure}
Jeżeli post zostanie poprawnie zmodyfikowany użytkownik, zostaje przeniesiony do strony z postami użytkownika. Na rysunku \ref{edit_post_success} przedstawiono pomyślne zmodyfikowanie posta.
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.36]{tests/add-edit-delete-posts/editted-post-success.png}
  \caption{Strona z postami użytkownika po pomyślnym edycji posta}
  \label{edit_post_success}
\end{figure}

\subsection{Edycja profilu użytkownika}
Aby zmodyfikować profil użytkownika, należy przejść na stronę profilu użytkownika oraz być zalogowanym na stronie. Następnie przechodzimy za pomocą przycisku \textit{My profile}. Na rysunku \ref{profile_page} przedstawiono stronę profilu użytkownika.
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.47]{tests/edit-profile/profile-page.png}
  \caption{Strona profilu użytkownika}
  \label{profile_page}
\end{figure}
Aby zmodyfikować profil, należy kliknąć przycisk \textit{Edit profile}. Na rysunku \ref{edit_profile} przedstawiono stronę edycji profilu użytkownika. W formularzu można zmienić takie dane jak numer telefonu, zdjęcie oraz nazwa użytkownika. Aby zmodyfikować profil należy kliknąć przycisk \textit{Edit profile}.
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.47]{tests/edit-profile/edit-profile-form.png}
  \caption{Strona edycji profilu użytkownika}
  \label{edit_profile}
\end{figure}
Dodatkowo na stronie profilu można zweryfikować adres email. Aby zweryfikować adres email, należy kliknąć przycisk \textit{Verify email}. Następnie na wybrany adres email otrzymujemy maila. W mailu znajduje się link do zweryfikowania adresu email.  Na rysunku \ref{verify_email} przedstawiono stronę profilu użytkownika po zweryfikowaniu adresu email. Strona informuje o wysłaniu maila na podany adres email.
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.45]{tests/edit-profile/send-verification-email.png}
  \caption{Strona profilu użytkownika po zweryfikowaniu adresu email}
  \label{verify_email}
\end{figure}
Na rysunku \ref{verify_email_message} przedstawiono email z linkiem do zweryfikowania adresu email. Ten mail został wygenerowany przez Firebase. 
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.32]{tests/edit-profile/verification-mail.png}
  \caption{Email z linkiem do zweryfikowania adresu email}
  \label{verify_email_message}
\end{figure}
Po kliknięciu w link użytkownik zostaje przekierowany do strony weryfikacji stworzonej przez Firebase. Firebase pozwala na zmodyfikowanie treści maila. Na rysunku \ref{verify_email_page} przedstawiono stronę weryfikacji adresu email.
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.33]{tests/edit-profile/mail-verification-successfull.png}
  \caption{Strona weryfikacji adresu email}
  \label{verify_email_page}
\end{figure}
Użytkownik także posiada edytowanie używanego przez siebie urządzenia. Aby zmodyfikować urządzenie, należy przejść na stronę profilu użytkownika oraz być zalogowanym na stronie. Następnie po wciśnięciu przycisku \textit{Edit Phone} użytkownik wybierze swoje urządzenie poprzez rozwijane menu. W tym menu zostają wyświetlone dostępne na stronie urządzenia. Na rysunku \ref{edit_phone} przedstawiono stronę edycji urządzenia.
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.47]{tests/edit-profile/phone-list.png}
  \caption{Strona edycji urządzenia}
  \label{edit_phone}
\end{figure}
Po pomyślnej zmianie urządzenia na stronie, pojawia się powiadomienie o pomyślnej zmianie urządzenia rysunek \ref{edit_phone_success}.
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.44]{tests/edit-profile/updated-user-device.png}
  \caption{Strona profilu użytkownika po pomyślnej zmianie urządzenia}
  \label{edit_phone_success}
\end{figure}

\subsection{Sortowanie i wyświetlanie telefonów}
Aby wyświetlić listę telefonów, należy przejść na podstronę o nazwie \textit{Phones}. Na tej stronie wyświetlane są wszystkie dostępne na stronie telefony. Telefony na stronie są grupowane ze względu na producenta. Na rysunku \ref{phones_page} przedstawiono stronę z listą telefonów.
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.42]{tests/display-phones/phone-page.png}
  \caption{Strona z listą telefonów}
  \label{phones_page}
\end{figure}
Zastosowana technika \textit{lazy loading} pozwoliła na opóźnienie załadowania zdjęć telefonów. Technika ta pozwala na opóźnienie ładowania statycznych plików jak zdjęcia. Obecnie przeglądarki obsługują przechowywanie zdjęć w pamięci podręcznej, co pozwala na ładowanie zdjęć z pamięci podręcznej. Pozwoliło to na szybsze ładowanie strony. Na serwer zostają przesyłane parametry jak: numer strony, liczba elementów na stronie oraz tryb sortowania. Użytkownik na stronie może zmienić tryb sortowania. Język Python udostępnia możliwość łatwą możliwość paginacji. Ta metoda nazywa się cięciem. W algorytmie \ref{slice_example} przedstawiono został przedstawiony kod odpowiedzialny za paginację telefonów.

Aby zmienić tryb sortowania, należy wybrać odpowiednią opcję z rozwijanego menu. Na rysunku \ref{reverse_sorting} przedstawiono zmianę trybu sortowania na \textit{Descending}.
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.42]{tests/display-phones/phone-sorting-reverse.png}
  \caption{Strona z listą telefonów po zmianie trybu sortowania}
  \label{reverse_sorting}
\end{figure}

\subsection{Porównanie trzech telefonów}
Aby porównać telefony, należy przejść na podstronę o nazwie \textit{Compare}. Użytkownik wybiera za pomocą rozwijanych menu trzy urządzenia. Urządzenia pobierane są z serwera, a następnie wyświetlane są na stronie. Każde wybranie urządzenia powoduje załadowanie informacji o urządzeniu. Na rysunku \ref{compare_page} przedstawiono stronę porównania przed wybraniem urządzeń do porównania.
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.42]{tests/compare-devices/compare-page.png}
  \caption{Strona z listą telefonów po zmianie trybu sortowania}
  \label{compare_page}
\end{figure}

Po wybraniu urządzenia użytkownik może porównać wybrane urządzenia. Informacje dotyczące urządzeń są przedstawione w formie tabeli. Na rysunku \ref{compare_three_devices} przedstawiono stronę porównania po wybraniu urządzeń.

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.36]{tests/compare-devices/compare-three-devices.png}
  \caption{Wynik wykonania porównania trzech urządzeń}
  \label{compare_three_devices}
\end{figure}

\section{Implementacja wybranych miejsc aplikacji}
W tej sekcji znajdują się opisy implementacji wybranych miejsc aplikacji. 

\subsection{Pobieranie informacji do porównania}
Aby pobrać informacje o telefonach wykorzystuje statyczną metodę występującą w JavaScript. Ta statyczna metoda nazywa się \textit{Promise.all}. Metoda ta pozwala na wykonanie jednocześnie kilku zapytań asynchronicznych. Pozwala to na szybsze pobieranie informacji o urządzeniach. W ten sposób czekamy na wszystkie zapytania jednocześnie, co zmniejsza czas oczekiwania na dane. Te dane są zwracane w formie tablicy. W algorytmie \ref{getting_devices} przedstawiono zastosowanie metody \textit{Promise.all}.

\begin{code}[H]
  \begin{minted}[
    frame=lines,
    framesep=2mm,
    baselinestretch=1.2,
    autogobble=true,
    breaklines,
    fontsize=\footnotesize,
    ]{TypeScript}
    const getComparison = async (deviceKeys: string[]) => {
      const comparisons: { [key: string]: DeviceDetails } = {}
      const promises = deviceKeys.map(async (key) => {
        return await getDetails(key)
      })
      const data = await Promise.all(promises)
      data.forEach((device: DeviceDetails) => {
        comparisons[device.key] = device
      })
      return comparisons
    }
  \end{minted}
  \caption{Endpoint znajdujący się w aplikacji - pozwala na paginację wykonaną metodą cięcia}
  \label{getting_devices}
\end{code}
Poprzez wykorzystanie języka TypeScript można było zdefiniować dokładnie jakich typów danych możemy się spodziewać w odpowiedzi. W tym przypadku oczekiwany jest obiekt, który zawiera klucz oraz wartość będącą obiektem typu \textit{DeviceDetails}. 

\subsection{Pobieranie informacji o urządzeniach}
W bazie danych znajduje się około 3500 telefonów. Załadowanie takiej ilości danych na stronie powoduje długi czas ładowania strony. Aby zredukować czas ładowania strony, zastosowano technikę \textit{Lazy Loading}. Pozwala ona na podzielenie danych na mniejsze fragmenty, co przekłada się na krótszy czas oczekiwania na nie. W ten sposób zwiększa się wydajność aplikacji.

W języku Python występuje technika nazywająca się \textit{slicing}, pozwala ona wydzielić z danej listy danych ich część. Dzięki składni języka python, slicing odbywa się za pomocą wprowadzeniu indeksów oraz dwukropka. Składania ta zapewnia też możliwość odczytywania ostatniej wartości za pomocą indeksu $-1$. W algorytmie \ref{slice_example} przedstawiono sposób wykorzystania tej techniki.

\begin{code}[H]
  \begin{minted}[
    frame=lines,
    framesep=2mm,
    baselinestretch=1.2,
    autogobble=true,
    breaklines,
    fontsize=\footnotesize
  ]{python3}
  @DEVICE.route("/")
  def get_all_devices_by_brand() -> Response:
      try:
          page_number = args.get("page_number")
          page_size = args.get("page_size")
          sort_mode = args.get("sort_mode", "ascending")
          devices = get_device_list_by_brands(db)
          sorted_devices = sort_devices(devices, sort_mode)
          result = {
              "data": sorted_devices,
              "total": len(devices),
              "totalPhones": count_phones(devices),
          }
          if page_size and page_number and sort_mode:
              start_index: int = (int(page_number) - 1) * int(page_size)
              end_index: int = start_index + int(page_size)
              result = {
                  "data": sorted_devices[start_index:end_index],
                  "total": len(devices),
                  "totalPhones": count_phones(devices),
              }
          return jsonify(result)
      except Exception as e:
          return Response(str(e), status=500)    
  \end{minted}
  \centering
  \caption{Punkt końcowy aplikacji pozwalający na pobranie informacji o urządzeniach}
  \label{slice_example}
\end{code}

\subsection{Edycja postów}
W aplikacji zaimplementowano edycję postów. Odbywa się ona poprzez wczytanie kolekcji postów z bazy danych Firestore \cite{firestore} oraz jej modyfikację. Dodatkowo w celu zabezpieczenie punktu końcowego aplikacji, zastosowano mechanizm autoryzacji. W tym celu wykorzystano token JWT |\ref{JWT}|, jest on weryfikowany poprzez usługę Firebase. Po zdekodowaniu tokena otrzymano identyfikator użytkownika, który służy do stworzenia odpowiedniego dokumentu w usłudze Firestore. 

Po uzyskaniu identyfikatora użytkownika przeszukujemy kolekcję \textit{post} w celu znalezienia odpowiedniego dokumentu. W dokumencie znajduje się lista postów, które należą do użytkownika. Po odczytaniu postów, w kolekcji jest znajdowany post o podanym identyfikatorze. Następnie następuje modyfikacja posta oraz zapisanie go w bazie danych.

W algorytmie \ref{edit_post_fragment} przedstawiono sposób wykorzystania tej techniki.

\begin{code}[H]
  \begin{minted}[
    frame=lines,
    framesep=2mm,
    baselinestretch=1.2,
    autogobble=true,
    breaklines,
    fontsize=\footnotesize
  ]{python3}
  @FORUM.route("/post", methods=["PUT"])
  def edit_post() -> Response:
      try:
          json_data: Dict[str, Any] = json.loads(request.data)
          headers: Dict[str, Any] = request.headers
          token: str = str(headers["Authorization"]).split(" ")[1]
          assert token is not None, "Authorization header is required"
          user_uid: str = verify_token(token)["uid"]
          post_id: str = json_data.get("id", "")
          db: FirestoreClient = current_app.config.get("FIRESTORE", None)
          posts: List[Dict[str, Any]] = get_docs_of_user(db, user_uid)
          edited_posts: List[Dict[str, Any]] = h_edit_post(posts, post_id, json_data)
          db.collection("posts").document(user_uid).set({"posts": edited_posts})
          return Response(f"Edited post with id: {post_id}.", status=200)
      except Exception as e:
          return Response(str(e), status=500)
  \end{minted}
  \caption{Zapis posta w bazie danych}
  \label{edit_post_fragment}
\end{code}

Dodatkowo w algorytmie \ref{edit_post_fragment} można zauważyć użycie biblioteki \textit{dataclasses}. Jest ona wykorzystywana do tworzenia klas, które reprezentują dane. W tym przypadku została wykorzystana do reprezentowania posta. Należy pamiętać, że obiektów klasy \textit{Post} nie można zapisać bezpośrednio w bazie danych. Należy skonwertować dany post do postaci słownika za pomocą metody \textit{asdict}. Jest to metoda pochodzą z biblioteki \textit{dataclasses}.

Wadą tego rozwiązania jest brak typów, które pozwoliły by na podpowiadanie w edytorze kodu. W celu zminimalizowania tego problemu, zastosowano adnotacje typów. Wydajność tego rozwiązania jest niewielka, ze względu na odczyt wszystkich postów użytkownika. Ta wydajność jest zależna od liczby postów użytkownika. 

Dodatkowym usprawnieniem tego rozwiązania mogłoby być zastosowanie mechanizmu paginacji. Dzięki zastosowania tego usprawnienia zostanie zwiększona wydajność aplikacji. 

\subsection{Dodawania postów}
W celu dodania posta do bazy danych, należy skomunikować się z bazą oraz pobrać listę postów w celu jej modyfikacji. Tak samo jak w przypadku edycji posta, należy zdekodować token \textit{JWT}, aby uzyskać informacje o użytkowniku. Tak samo jak w przypadku edytowania posta, należy odczytać wszystkie posty użytkownika. Następnie należy dodać nowy post do listy postów użytkownika. Następnie należy zapisać listę postów użytkownika w bazie danych.

Również w tym przypadku zastosowano biblioteki \textit{dataclasses}, aby reprezentować posty. Dodatkowo, aby zadbać o integralność danych w bazie danych została zastosowano biblioteka \textit{uuid}. Posłużyła ona do generowania unikalnych identyfikatorów postów.

W algorytmie \ref{create_new_post_fragment} przedstawiono sposób dodawania posta do bazy danych.

\begin{code}[H]
  \begin{minted}[
    frame=lines,
    framesep=2mm,
    baselinestretch=1.2,
    autogobble=true,
    breaklines,
    fontsize=\footnotesize
  ]{python3}
  @FORUM.route("/post", methods=["POST"])
  def create_new_post() -> Response:
      try:
          data: Dict[str, Any] = json.loads(request.data)
          headers: Dict[str, Any] = request.headers
          token: str = str(headers["Authorization"]).split(" ")[1]
          assert token is not None, "Authorization header is required"
          user_uid: str = verify_token(token)["uid"]
          user = get_user_information(user_uid)
          db: FirestoreClient = current_app.config.get("FIRESTORE", None)
          new_post = Post(
              id=str(uuid1()),
              uid=user_uid,
              title=data.get("title", ""),
              description=data.get("description", ""),
              type=data.get("type", ""),
              device_key=data.get("device_key", ""),
              user=user,
          )
          posts: List[Dict[str, Any]] = get_docs_of_user(db, user_uid)
          posts.append(asdict(new_post))
          db.collection("posts").document(user_uid).set({"posts": posts})
          return jsonify({"post": asdict(new_post)})
      except Exception as e:
          return Response(str(e), status=500)
  \end{minted}
  \caption{Dodanie posta w bazie danych}
  \label{create_new_post_fragment}
\end{code}

\subsection{Usuwanie postów}
W celu usunięcia posta z bazy danych, należy pobrać listę postów użytkownika oraz zmodyfikować, a następnie wysłać zapisaną listę postów użytkownika do bazy danych. Tak samo jak w przypadku dodawania bądź edycji należy pobrać informacje o użytkowniku. Uzyskane jest to poprzez zdekodowanie tokena \textit{JWT}. W ten sposób jesteśmy odczytać identyfikator użytkownika, co pozwala na odczytanie listy postów użytkownika.

Po odczytaniu listy, należy znaleźć post o podanym identyfikatorze. Następnie należy usunąć post z listy postów użytkownika. Na samym końcu zapisujemy stan listy postów w bazie danych. W algorytmie \ref{delete_post_fragment} przedstawiono sposób usuwania posta z bazy danych.

\begin{code}[H]
  \begin{minted}[
    frame=lines,
    framesep=2mm,
    baselinestretch=1.2,
    autogobble=true,
    breaklines,
    fontsize=\footnotesize
  ]{python3}
  @FORUM.route("/post", methods=["DELETE"])
  def delete_post() -> Response:
      try:
          data: Dict[str, Any] = json.loads(request.data)
          headers: Dict[str, Any] = request.headers
          token: str = str(headers["Authorization"]).split(" ")[1]
          assert token is not None, "Authorization header is required"
          user_uid: str = verify_token(token)["uid"]
          post_id: str = data.get("post_id", "")
          db = current_app.config.get("FIRESTORE", None)
          posts: List[Dict[str, Any]] = get_docs_of_user(db, user_uid)
          post: Optional[Dict[str, Any]] = find_post_by_id(post_id, posts)
          assert post is not None, f"Post with id: {post_id} not found!"
          posts.remove(post)
          db.collection("posts").document(user_uid).set({"posts": posts})
          return Response(f"Removed post with id: {post_id}.", status=200)
      except Exception as e:
          return Response(str(e), status=500)
  \end{minted}
  \caption{Usuwanie posta z bazy danych}
  \label{delete_post_fragment}
\end{code}

Dodatkowo można zauważyć, że zastosowano obsługę błędów w postaci wyjątków. W przypadku wystąpienia błędu, zwracany jest kod odpowiedzi HTTP 500. W przypadku braku błędu, zwracany jest kod odpowiedzi HTTP 200 oraz odpowiedź w formacie \textit{JSON} |\ref{JSON}|. 

\subsection{Dodawanie zdjęć do Google Cloud Store}
Aby dodać zdjęcia do Google Cloud Store, należy wykorzystać bibliotekę \textit{google-cloud-storage}. W celu dodania zdjęć należy skorzystać z specjalnego obiektu \textit{FileStorage} z biblioteki \textit{werkzeug}. Przechowuje on informacje o nazwie pliku ze zdjęciem oraz strumień z danymi na jego temat. 

Aby zachować rozróżnienie w nazwach zdjęć, zastosowano grupowanie po identyfikatorach postów. Każdy post, który zawiera zdjęcia posiada swój unikalny katalog nazwany za pomocą identyfikatora posta. W ten sposób można bardzo szybko zlokalizować zdjęcia danego posta. W każdym z katalogów znajdują się zdjęcia danego posta, nazwane zgodnie z tym co przesłał na serwer.

W algorytmie \ref{upload_to_images_storage_fragment} przedstawiono sposób dodawania zdjęć do Google Cloud Store. 

\begin{code}[H]
  \begin{minted}[
    frame=lines,
    framesep=2mm,
    baselinestretch=1.2,
    autogobble=true,
    breaklines,
    fontsize=\footnotesize
  ]{python3}
  def upload_to_images_storage(
    files: Dict[str, FileStorage], folder_name: str, client: storage.Client
) -> List[str]:
    file_names: List[str] = []
    bucket: storage.Bucket = list(client.list_buckets())[0]
    for _, file_data in files.items():
        blob = bucket.blob(f"{folder_name}/{file_data.filename}")
        blob.upload_from_file(file_data.stream, content_type="image/jpeg")
        file_names.append(blob.public_url)
    return file_names
  \end{minted}
  \caption{Dodanie zdjęć do Google Cloud Storage}
  \label{upload_to_images_storage_fragment}
\end{code}

\subsection{Pobieranie informacji z GSM Arena API}
Aby pobrać informacje o telefonie z serwisu \textit{GSM Arena API}, uzyskano to za pomocą biblioteki \textit{requests}. Jest to biblioteka, która umożliwia wysyłanie żądań HTTP na podany adres. W przypadku pobierania danych z internetu użyto metody \textit{GET}. W celu wysłania danych do serwisu znajdującego się w sieci, należy skorzystać z metody \textit{POST}.

Zgodnie z dokumentacją \textit{GSM Arena API} \cite{gsm_arena_api_reference} występują tam dwie metody żądań: \textit{GET} oraz \textit{POST}. W przypadku pobierania informacji o telefonach wykorzystujemy metodę \textit{GET}. Dodatkowo przekazujemy funkcji ukazanej w algorytmie \ref{get_from_gsm_arena} parametry, które są wymagane przez serwis. W tych parametrach jest zawarta ścieżka, co pozwala na pobranie danych z odpowiedniego punktu końcowego \textit{GSM Arena API}.

W algorytmie \ref{get_from_gsm_arena} przedstawiono sposób pobierania informacji z serwisu \textit{GSM Arena API}.

\begin{code}[H]
  \begin{minted}[
    frame=lines,
    framesep=2mm,
    baselinestretch=1.2,
    autogobble=true,
    breaklines,
    fontsize=\footnotesize
  ]{python3}
  def get_from_gsm_arena(params: Dict[str, str], search: str = "") -> Dict[str, Any]:
    req = r.get(f"{GSM_ARENA_API_URL}{search}", params)
    return req.json()
  \end{minted}
  \caption{Żądanie GET do serwisu GSM Arena API}
  \label{get_from_gsm_arena}
\end{code}

W algorytmie \ref{post_from_gsm_arena} przedstawiono sposób wysyłania informacji z serwisu \textit{GSM Arena API}.
\begin{code}[H]
  \begin{minted}[
    frame=lines,
    framesep=2mm,
    baselinestretch=1.2,
    autogobble=true,
    breaklines,
    fontsize=\footnotesize
  ]{python3}
  def post_to_gsm_arena(params: Dict[str, str]) -> Dict[str, Any]:
    req = r.post(GSM_ARENA_API_URL, data=json.dumps(params))
    return req.json()
  \end{minted}
  \caption{Żądanie POST do serwisu GSM Arena API}
  \label{post_from_gsm_arena}
\end{code}

Należy nadmienić, że w przypadku tych dwóch funkcji, zwracana są nam dane w formie \textit{JSON} \ref{JSON}. Pozwala to na łatwe odczytanie danych, które są zwracane przez serwis.

\subsection{Stworzenie funkcji wywoływanych okresowo}
W trakcie pracy nad projektem zauważono, że występuje potrzeba zapisywania informacji o telefonach w bazie danych. Ta dodatkowa funkcjonalność została dodana ze względu na ograniczenia występujące w serwisie \textit{GSM Arena API}. Serwer ze względu na ograniczenia Google App Script \cite{google_app_script}, może wykonać tylko 50 zapytań. Zatem użytkownik jedynie wysyła zapytania do bazy o telefony.

Zatem, aby telefony w bazie danych były aktualne, następuje zapisanie co godziny telefonów do bazy danych. W tym celu został zastosowany APScheduler \cite{flask_apscheduler}. Jest to biblioteka, która pozwala na wykonywanie zadań okresowo (\textit{cronjob}).

Aby rozpocząć pracę z \textit{APScheduler} należy go skonfigurować oraz dodać zadania. W tym celu została stworzona funkcja, która specyfikuje interwał czasowy, w którym zadanie ma być wykonywane, identyfikator, czas, w którym powtarza wywołanie po nieudanej próbie wykonania zadania oraz typ zadania. Dodatkowo biblioteka ta integruje się z obiektem \textit{Flask}, co powoduje to, że APScheduler może wykonywać zadania w kontekście obiektu \textit{Flask}.

W algorytmie \ref{configure_apscheduler} przedstawiono sposób konfiguracji APScheduler.

\begin{code}[H]
  \begin{minted}[
    frame=lines,
    framesep=2mm,
    baselinestretch=1.2,
    autogobble=true,
    breaklines,
    fontsize=\footnotesize
  ]{python3}
    def get_app_scheduler(app: Flask) -> APScheduler:
    scheduler = APScheduler(app=app)
    with app.app_context():
        scheduler.add_job(
            id="save_brands_to_db",
            func=lambda: brand_task(app),
            trigger="interval",
            seconds=3600,
            misfire_grace_time=900,
        )
        scheduler.add_job(
            id="save_devices_to_db",
            func=lambda: device_task(app),
            trigger="interval",
            seconds=3600,
            misfire_grace_time=900,
        )
    return scheduler
  \end{minted}
  \caption{Konfiguracja APScheduler}
  \label{configure_apscheduler}
\end{code}

W przypadku tej aplikacji, zadanie polega na pobraniu listy telefonów z serwisu \textit{GSM Arena API} i zapisaniu ich do bazy danych. W algorytmie \ref{device_task} przedstawiono sposób wywoływania funkcji okresowo odpowiedzialnej za odczyt i zapis listy telefonów w bazie danych.

\begin{code}[H]
  \begin{minted}[
    frame=lines,
    framesep=2mm,
    baselinestretch=1.2,
    autogobble=true,
    breaklines,
    fontsize=\footnotesize
  ]{python3}
  def device_task(app: Flask) -> None:
    with app.app_context():
        logger.info("[TASK] Starting device task")
        db: FirestoreClient = app.config.get("FIRESTORE")
        devices: List[DeviceResponse] = get_device_list_by_brands()
        parsed_devices = [asdict(device) for device in devices]
        db.collection("devices").document("devices").set({"devices": parsed_devices})
  \end{minted}
  \caption{Przykład funkcji wywoływanej okresowo - pobieranie listy urządzeń}
  \label{device_task}
\end{code}

W celu zminimalizowania ilości zapytań do \textit{GSM Arena API} została stworzona funkcja, która wysyła zapytanie o producentów do \textit{GSM Arena API}, a następnie producenci są zapisywani w bazie danych. W algorytmie \ref{brand_task} przedstawiono funkcji działającej okresowo.

\begin{code}[H]
  \begin{minted}[
    frame=lines,
    framesep=2mm,
    baselinestretch=1.2,
    autogobble=true,
    breaklines,
    fontsize=\footnotesize
  ]{python3}
  def brand_task(app: Flask) -> None:
    with app.app_context():
        logger.info("[TASK] Starting brand task")
        db: FirestoreClient = app.config.get("FIRESTORE")
        brands: List[Brand] = _get_brand_list()
        dicts_brands: List[Dict[str, Any]] = [
            asdict(brand) for brand in brands if brand.brand_name != ""
        ]
        db.collection("brands").document("brands").set({"brands": dicts_brands})
  \end{minted}
  \caption{Przykład funkcji wywoływanej okresowo - pobieranie listy producentów}
  \label{brand_task}
\end{code}


