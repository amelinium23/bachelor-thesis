\section{Założenia projektowe}
W tym rozdziale zostały zawarte wszystkie wymagania funkcjonalne oraz niefunkcjonalne aplikacji. Projekt posiada funkcjonalności i założenia, które są zawarte w rozdziale \ref*{ideal_solution}. 
\subsection{Wymagania funkcjonalne}
\subsubsection{Użytkownik niezalogowany}
\begin{enumerate}
    \item Użytkownik posiada możliwość zalogowania się za pomocą e-maila i hasła.
    \item Użytkownik posiada możliwość przeglądania oraz sortowania marek telefonów komórkowych.
    \item Użytkownik posiada możliwość przeglądania oraz sortowania telefonów komórkowych.
    \item Użytkownik posiada możliwość przeglądania najnowszych postów z forum.
    \item Użytkownik posiada możliwość porównywania maksymalnie trzech urządzeń znajdujących się na stronie.
    \item Użytkownik posiada możliwość przeglądania cen dla wybranego modelu telefonu komórkowego.
\end{enumerate}
\subsubsection{Użytkownik zalogowany}
\begin{enumerate}
    \item Użytkownik zalogowany musi mieć możliwość wykonywania wszystkich czynności użytkownika niezalogowanego.
    \item Użytkownik posiada możliwość weryfikacji adresu e-mail.
    \item Użytkownik posiada możliwość edycji oraz dodawania swojego aktualnego telefonu.
    \item Użytkownik posiada możliwość dodawania, edycji oraz usuwania swoich postów.
    \item Użytkownik posiada możliwość przeglądania oraz sortowania swoich postów.
    \item Użytkownik posiada możliwość reagowania na posty.
    \item Użytkownik posiada możliwość przeglądania oraz dodawania opinii dotyczących urządzeń.
\end{enumerate}

\subsection{Wymagania niefunkcjonalne}
\begin{enumerate}
    \item System łączy się z zewnętrznym serwisem (API GSM Arena) w celu pozyskania danych dotyczących telefonów komórkowych.
    \item System ma możliwość zapisywania i odczytywania danych znajdujących się w bazie danych.
    \item System musi przechowywać dane na temat użytkownika, tworzącego opinie dotyczące urządzeń.
\end{enumerate}

\newpage
Na rysunku \ref*{use_case} zostały przedstawione przypadki użycia aplikacji.
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.41]{diagrams/useCaseDiagram.png}
    \caption{Diagram przypadków użycia}
    \label{use_case}
\end{figure}

\subsection{Użyte technologie}
\subsubsection{Frontend}
Część frontendowa została zbudowana w oparciu o język TypeScript \cite{TypeScript}. TypeScript to język opracowany przez firmę Microsoft, który pozwala na wprowadzenie statycznego typowania do JavaScript. Wadą tego języka jest kompilowanie go do JavaScriptu, co wydłuża czas budowania aplikacji. Dodatkowo, dzięki typom i integracji IDE \ref{IDE} występuje możliwość lepszego podpowiadania, jakie własności posiada dany obiekt.
Język ten został wybrany ze względu na tworzenie własnych typów, aby móc odwzorować typy, które zostały zdefiniowane w projekcie, co usprawnia pracę programisty oraz zwiększa czytelność kodu. 

W warstwy widoku została zastosowana biblioteka React \cite{React}. Jest to biblioteka do warstwy widoku, która pozwala na tworzenie komponentów w celu zbudowania widoku. Charakteryzuje się ona dużą wydajnością dzięki zastosowania mechanizmu Virtual DOM, który pozwala na szybsze porównywanie zmian pomiędzy faktycznymi elementami na stronie. Pozwala na tworzenie komponentów, które będziemy mogli wielokrotnie używać w wielu miejscach strony. Do poruszania się po stronie w projekcie została użyta biblioteka React router \cite{react_router}, która umożliwia na zdefiniowanie podstron oraz nawigację pomiędzy nimi. Do umieszczania powiadomień na stronie została użyta biblioteka react toastify \cite{react_toastify}.

Wykorzystaną biblioteką z komponentami UI jest Bootstrap. Pozwala ona na użycie gotowych komponentów, które zostały stylowane przez twórców frameworka Bootstrap. Framework ten jest standardem dla aplikacji webowych, co spowodowało zbudowanie wielu innych frameworków opartych na Bootstrapie. Ta biblioteka została wybrana ze względu na prostotę jej użycia oraz wyglądu komponentów. 

\subsubsection{Backend}
Część backendowa została oparta na języku interpretowanym Python \cite{python}. Python jest to język opracowywany przez Python Software Foundation \cite{psf}, który pozwala na tworzenie aplikacji webowych czy prowadzenie analiz statystycznych. Język ten jest uniwersalny, dzięki czemu mamy możliwość zbudowania aplikacji webowych, konsolowych czy tworzenia sieci neuronowych. Wadą tego języka jest jego wydajność - wynika to z faktu działania interpretera, który musi skonwertować program na kod bajtowy, który następnie jest odczytywany i uruchamiany na maszynie wirtualnej Python'a. Zaletą tego języka jest łatwość budowania aplikacji webowych wraz z składnią języka i systemem wcięć.

Frameworkiem, który został użyty do zbudowania API jest jeden z najpopularniejszych frameworków Flask \cite{flask}. Flask jest to framework, cechującym się dużą wydajnością. Posiada on duże możliwość rozbudowy poprzez pluginy, dzięki którym mamy możliwość łączenia się z bazami danych czy umożliwieniem autoryzacji. W tym projekcie Flask, został rozszerzony o bibliotekę Flask-APScheduler \cite{flask_apscheduler}. Plugin ten pozwala na zaplanowanie czynności w czasie, dzięki czemu jest możliwe cogodzinne wpisywanie danych telefonów do bazy danych. API pozwala na autoryzację użytkowników przy pomocy Firebase \cite{firebase}, dodawaniem zdjęć do Cloud Storage \cite{cloud_storage} i dodawaniem urządzeń użytkownika oraz postów do bazy danych Firestore \cite{firestore}. Flask został wybrany do projektu ze względu na możliwość związaną z rozszerzaniami oraz wydajność.

\subsection{Użyte narzędzia Continous Integration i Continuous Delivery}
W projekcie autor zdecydował się na użycie trzech narzędzi Continous Integration |\ref{CI}| oraz Continous Delivery |\ref{CD}|. Ze względu na rozdzielenie części frontendowej i backendowej na dwa repozytoria, pozwoliło to na łatwiejsze zastosowanie Github Actions. Github Actions \cite{github_actions} jest to funkcja, które pozwala na przeprowadzenie testów, zbudowanie i wdrożenie aplikacji do publicznego użycia. Dzięki tej funkcji jesteśmy w stanie sprawdzać stan budowania aplikacji czy zobaczyć raport wykonania testów.

Dla części backendowej została stworzona akcja za pomocą Github Actions, której zadaniem jest wdrożenie aplikacji na hosting render \cite{render}. Jest to jeden z wiodących hostingów \cite{render_top} dla aplikacji webowych stworzonych w języku Python. Wadą tego serwisu jest współdzielenie mocy obliczeniowej na darmowym poziomie subskrypcji. Zaletą tego hostingu jest integracja z portalem GitHub, dzięki czemu za pomocą jednego kliknięcia mamy dostęp do kodu aplikacji.

Dla repozytorium z częścią frontendową wykonano integrację z hostingiem Vercel. Vercel \cite{vercel} jest to hosting, który pozwala na wprowadzenie aplikacji frontendowych. Hosting ten charakteryzuje się dużą liczbą szablonów, dzięki którym nie martwimy się o specjalną konfigurację dla danej aplikacji. Kolejną możliwością tego hostingu jest darmowe przypisanie własnych domen, co jest jednocześnie wadą. Posiadając darmową subskrypcję jesteśmy ograniczeni do domen kończących się na \textit{vercel.app} Hosting ten posiada integrację z wieloma systemami kontroli wersji: Github, Gitlab czy Bitbucket. Dodatkową opcją jest optymalizacja zdjęć, które posiada hosting, co pozwala na ograniczenie pobierania obrazów na stronie.

\section{Architektura aplikacji}
W tej sekcji znajdują się opis jak zostały podzielone moduły aplikacji zarówno części frontendowej, jak i backendowej. Opisane także zostały wybrane źródła danych, które zostały wykorzystane w projekcie. Zawarty został również opis wraz z diagramem encji.

\subsection{Źródła danych} \label{data_sources}
W projekcie zostały zastosowane dwa źródła danych. Zostały one wybrane ze względu na ich wysoką dostępność w internecie.
Podstawowym źródłem danych jest \linebreak GSM Arena API \cite{gsm_arena_api}, dzięki czemu mogliśmy uzyskać dane dotyczące telefonów komórkowych. Dodatkowym źródłem danych są serwisy aukcyjne, które dostarczają aktualne ceny telefonów komórkowych.

\subsubsection{GSM Arena API}\label{api}
W aplikacjach webowych często się wykorzystuje API |\ref{API}|, pozwalają one na dostarczenie danych w formacie JSON. Pozwala to także na wysyłanie danych na serwer w celu ich przetworzenia. W przypadku API rozwijanym przez autora pracy jest API pozwalające na dodawanie, edycję czy usuwanie postów danego użytkownika.

Źródłem danych o telefonach jest GSM Arena API \cite{gsm_arena_api}, stworzone przez Kyaw Htut. Dostarcza one dane dotyczące urządzeń znajdujących się na portalu \linebreak GSM Arena \cite{gsm_arena}. API wykorzystuję metodę Web Scraping, dzięki któremu otrzymujemy dane w formacie JSON.

Wadą tego rozwiązania jest umieszczenie skryptu na serwisie \linebreak Google App Script \cite{google_app_script}. Zostało to wymuszone, z powodu dodatkowej biblioteki Cheerio, które wykorzystuję API. Dodatkowo Google App Script posiada ograniczoną liczbę możliwych wywołań API. Warto zaznaczyć, że API nie jest oficjalnie udostępnione przez GSM Arena, dlatego nie jestem w stanie zapewnić, że będzie ono działało w przyszłości. Sam autor dostarcza pełną dokumentację API za pomocą programu Postman. W dokumentacji \cite{gsm_arena_api_reference} zostały zawarte przykładowe żądania, co pozwala na łatwe wykorzystanie API.

\subsubsection{Serwisy aukcyjne}
Drugim źródłem danych są serwisy aukcyjne. W projekcie zostały wykorzystane serwisy jak: Amazon, Ebay, AliExpress oraz sklepy producentów. Te dane zostały udostępnione w API Gsm Areny, nie było więc konieczności ich pobierania z serwisów.

Początkowo w projekcie miały znaleźć się dane serwisów zagranicznych  oraz zostać rozszerzone o dane z polskich serwisów aukcyjnych takich jak: Allegro, Olx, Skąpiec czy Ceneo. Serwisy te, aby pobrać dane, pobierają dodatkową opłatę, co więcej należy spełnić ich warunki, aby móc korzystać z API.

W przypadku serwisu Allegro, należy być w programie partnerskim oraz aplikacja w Allegro musi być zweryfikowana. Weryfikacja odbywa się po skontaktowaniu się z Allegro. Aby otrzymać weryfikację, należy mieć 100 aktywnych użytkowników, zarejestrowanych w aplikacji oraz być w programie partnerskim.

Na rysunku \ref*{allegro_verification} została przedstawione warunki weryfikacji aplikacji.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.55]{responses/allegro_response.png}
    \caption{Odpowiedź Allegro na prośbę o weryfikację aplikacji}
    \label{allegro_verification}
\end{figure}

Zatem integracja z tym serwisem nie była możliwa. Podobny sposób działania mają także serwisy Skąpiec \cite{skapiec} i Ceneo \cite{ceneo}. Również wymagają dołączenie do programu partnerskiego, przez co jest uniemożliwiony dostęp do ofert publiczny. Wymienione serwisy nie udostępniają danych dotyczących ofert publicznych, co uniemożliwia pobranie danych o cenach telefonów komórkowych.

Innym przypadkiem jest serwis OLX. Nie udostępnia on możliwości pobierania ofert publicznych, a jedynie ofert zalogowanego użytkownika. Na rysunku \ref*{olx_response} została przedstawiona odpowiedź serwisu na prośbę o udostępnienie API.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.58]{responses/olx_response.png}
    \caption{Odpowiedź OLX na prośbę o weryfikację aplikacji}
    \label{olx_response}
\end{figure}

W rezultacie, w projekcie zostały jedyne dane z serwisów aukcyjnych, które nie wymagały dodatkowej weryfikacji czy też opłaty.

\subsection{Wybrana baza danych}
W projekcie została wykorzystana baza danych NoSQL \cite{NoSQL} w usłudze Cloud Firestore \cite{firestore}. Baza ta została zbudowana w paradygmacie dokumentowym \cite{document_based_database}, co pozwala na łatwe zapisywanie danych. Zaletą takiego rozwiązania jest brak określenia dokładnej struktury danych. W przypadku zmiany typu danego pola, nie musimy przeprowadzać migracji bazy danych, tylko możemy dowolnie zmienić strukturę danych. W przypadku tego projektu jest to dobre rozwiązanie, ze względu na pobieranie danych z zewnętrznych źródeł, które mogą się zmieniać.

Dzięki paradygmatowi dokumentowemu, baza danych została podzielona na kolekcję:
\begin{enumerate}
    \item \textit{brands} - przechowuje dane o producentach telefonów. Kolekcja, ta została stworzona, jako kopia zapasowa danych, pobieranych z GSM Areny. W przypadku, gdyby serwis nie był dostępny, można by w łatwy sposób zastąpić dane z bazy danych. Zawiera ona jeden dokument, który składa się z listy producentów, wraz z ich nazwą i identyfikatorem.
    \item \textit{devices} - przechowuje dane o telefonach. Tak samo jak w przypadku producentów, należy także synchronizować dane wraz z producentami pobranymi z GSM Areny. Zawiera jeden dokument, który składa się z pogrupowanej listy telefonów, wraz z ich nazwą, identyfikatorem, zdjęciem w postaci linku oraz klucza, który pozwala otrzymać specyfikację danego urządzenia.
    \item \textit{device} - przechowuje dane o telefonie użytkownika. Zawiera ona dokumenty, które są nazywane identyfikatorem użytkownika, w celu uniknięcia duplikacji danych. W dokumentach znajdują się dane o telefonie użytkownika, wraz z jego nazwą, zdjęciem oraz kluczem, który pozwala otrzymać specyfikację danego urządzenia.
    \item \textit{opinions} - przechowuje opinie dotyczące danego urządzenia. Zawiera ona dokumenty, które są nazywane identyfikatorem urządzenia, w celu uniknięcia duplikacji danych. W dokumentach znajdują się dane o opinii, wraz z jej treścią, tytułem, identyfikatorem oraz informacją o użytkowniku, który wystawił daną opinie.
    \item \textit{posts} - przechowuje posty użytkowników. Zawiera ona dokumenty, które są nazywane identyfikatorem użytkownika, w celu uniknięcia duplikacji danych. W dokumentach znajdują się dane o postach, wraz z treścią, tytułem, identyfikatorem, komentarzami oraz informacją o użytkowniku, który wystawił daną opinie. W przypadku, gdy użytkownik, wystawił prośbę o wycenę telefonu, wtedy użytkownik może dodać zdjęcia telefonu. W bazie są one przechowywane jako linki, do zdjęć znajdujące się na Google Cloud Storage.
\end{enumerate}

W tej bazie można wyróżnić kilka struktur danych. Struktury te są słownikami klucz-wartość, co pozwala na szybszą zmianę oraz wpisywanie danych. W przypadku dodawania nowych kluczy, nie musimy przeprowadzać migracji bazy danych, co pozwala na dowolne zmiany struktury danych.

Na rysunku \ref{database} przedstawiono schemat struktur danych w bazie danych oraz ich zależności pomiędzy nimi.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.46]{diagrams/entityDiagram.png}
    \caption{Schemat struktur danych w bazie danych}
    \label{database}
\end{figure}

\subsection{Struktura aplikacji}
\subsubsection{Backend}
Backend został zbudowany w oparciu o moduły, występujące w języku Python \cite{python}. Pozwoliło to na łatwe podzielenie kodu na poszczególne moduły aplikacji. Poszczególne punkty końcowe API zostały zamknięte w odpowiednim pakiecie. W frameworku Flask \cite{flask}, występuje pojęcie \textit{Blueprint} \cite{flask_blueprint}. Koncept ten zakłada, że projekt można podzielić na pomniejsze aplikacje, które mogą zostać wykorzystywane w wielu aplikacjach. Taka architektura, poprawia ona czytelność kodu, łatwość utrzymania oraz możliwość łatwego rozszerzenia aplikacji.

W aplikacji każdy punkt końcowy posiada swój pakiet, dzięki czemu można łatwo go zlokalizować. Zostały one nazwane prefiksami ścieżek do poszczególnych punktów końcowych. Przykładowo, punkt końcowy o nazwie \textit{user}, będzie zdefiniowany w folderze \textit{user}. W każdym pakiecie znajdą się podpakiety, gdzie można znaleźć definicję struktur danych (pakiet \textit{model}), bądź dodatkowe funkcje pomocnicze funkcje (pakiet \textit{utils}). Wyjątkiem w tej architekturze są dwa pakiety: \textit{main} oraz \textit{docs}.

Pakiet \textit{main} zawiera funkcję pozwalające na stworzenie aplikacji, klasę odpowiedzialną za konfigurację projektu oraz moduł, który pozwala na udostępnienie dostępu do serwisu Firebase, Firestore oraz Google Cloud Storage. W tym module znajdują się także szablony HTML, w których stworzona jest główna strona aplikacji oraz strony, które wyświetlą się w przypadku błędu serwera, bądź nie odnalezienia danego punktu końcowego. Dodatkowo zostały tam zdefiniowane funkcje, które są wykorzystywane do zadań przy użyciu Flask-APScheduler \cite{flask_apscheduler}.

Natomiast moduł \textit{docs} zawiera dokumentację API, gdzie została stworzona szablon, którego zadaniem jest wyświetlenie wszystkich punków końcowych aplikacji. Tak samo jak moduł \textit{main}, zawiera on również szablony HTML. Zawiera on także, funkcję, dzięki której możemy pobrać wszystkie możliwe punkty końcowe, znajdujące się w aplikacji.

Na rysunku \ref*{backend} przedstawiono schemat modułów aplikacji wraz z ich podmodułami.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.8]{diagrams/backendModules.png}
    \caption{Schemat części backendowej modułów aplikacji}
    \label{backend}
\end{figure}

W aplikacji zostały skonfigurowane narzędzia, pomagające w pracy przy projekcie. Pakiety potrzebne do uruchomienia aplikacji zostały zainstalowane w wirtualnym środowisku. Zostało to uzyskane za pomocą pakietu \textit{virtualenv} \cite{virtualenv}. Pozwala to na uruchamianie kodu, na zdefiniowanym przez nas środowisku. Umożliwia to także testowanie w środowisku testowym z minimalnymi wymaganiami. 

Wszystkie narzędzia zostały zainstalowane za pomocą menadżera pakietów Pythona \textit{pip} \cite{pip}. W celu poprawienia jakości kodu, zostały zastosowane narzędzia:
\begin{enumerate}
    \item \textit{mypy} - narzędzie to pozwala na statyczne sprawdzanie typów w Pythonie \cite{mypy}. Dzięki temu można wykryć błędy w kodzie, które mogłyby zostać zignorowane przez interpreter. 
    \item \textit{black} - narzędzie to pozwala na automatyczne formatowanie kodu \cite{black}. Dzięki temu można uniknąć sytuacji, w której kod jest niespójny, co może utrudnić jego czytanie.
    \item \textit{pre-commit} - narzędzie to pozwala na automatyczne uruchamianie innych narzędzi, w celu sprawdzenia poprawności kodu \cite{pre_commit}.
\end{enumerate}

\subsubsection{Frontend}
Część frontendowa została zbudowana w oparciu o architekturę, która została wykonana zgodnie z zasadami, które można znaleźć w dokumentacji \cite{React_file_structure} React \cite{React}. Struktura ta zakłada, że lokalizujemy wszystkie pliki związane z daną stroną bądź komponentem w tym samym folderze. Przykładowo, jeżeli mamy komponent, który posiada własny arkusz stylów, umieszczamy go w tym samym folderze, co kod źródłowy tego komponentu.

W projekcie zostały użyty język TypeScript \cite{TypeScript}, co rozszerza dodatkowo strukturę o dodatkowy katalog \textit{types}. W tym katalogu zostały umieszczone typy \cite{TypeScript_types}, co pozwoliło na statyczne typowanie zmiennych. Co więcej, zostały zdefiniowane typy dla obiektów, które są zwracane przez API. Wszystkie typy zostały zdefiniowane w plikach z nazwą odpowiadającą ich przeznaczeniu. Konfigurację języka TypeScript można znaleźć w pliku \textit{tsconfig.json}.

Katalog z kodem źródłowym został podzielony na pomniejsze katalogi:
\begin{enumerate}
    \item \textit{components} - zawiera komponenty, które zostały wykorzystane w aplikacji. Każdy komponent został umieszczony w osobnym folderze, gdzie znajduje się kod źródłowy komponentu wraz z arkuszem stylów (jeżeli taki posiada). W katalogu znajdują się komponenty odpowiedzialne za wyświetlanie danych, formularzy czy list.
    \item \textit{context} - zawiera pliki związane z wykorzystaniem ContextAPI \cite{React_context} w aplikacji. Kontekst jest wykorzystywany do przechowywania danych, które są wykorzystywane w wielu miejscach aplikacji. W tym katalogu znajdują się pliki, które są odpowiedzialne za tworzenie kontekstu wraz z definicją funkcji odpowiedzialnych za zmianę stanu. W tym folderze także znajdują się definicje typów dla kontekstu.
    \item \textit{css} - zawiera globalne arkusze stylów, które zostały wykorzystane w aplikacji. W tym arkuszu znajdują się definicje czcionek wraz z definicją paska przewijania, które zostały użyte w aplikacji.
    \item \textit{pages} - zawiera definicję wszystkich podstron występujących w aplikacji. Każda podstrona została umieszczona w osobnym folderze, gdzie znajduje się kod źródłowy podstrony wraz z arkuszem stylów (jeżeli taki posiada).
    \item \textit{services} - zawiera definicje wszystkich serwisów występujące w aplikacji. Każda funkcjonalność, posiada swój serwis, dzięki czemu można łatwo wykorzystać tę funkcjonalność w wielu miejscach aplikacji. W tym katalogu znajdują się funkcje odpowiedzialne za komunikację z API.
    \item \textit{types} - zawiera definicję typów występujących w aplikacji. W tym katalogu znajdują się typy dla obiektów, które są zwracane przez API.
    \item \textit{utils} - zawiera funkcje pomocnicze, które są wykorzystywane w wielu miejscach aplikacji. W tym katalogu znajdują się funkcje odpowiedzialne za definicję kolorów, które są ustawiane dynamiczne, pomocnicze funkcje oraz stałe wykorzystane w aplikacji.
\end{enumerate}

Na rysunku \ref{module_frontend} przedstawiono schemat modułów części frontendowej.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{diagrams/moduleFrontend.png}
    \caption{Schemat części frontendowej modułów aplikacji}
    \label{module_frontend}
\end{figure}

W projekcie także zostały skonfigurowano narzędzia, które pomagają w pracy przy projekcie. Wszystkie narzędzia zostały zainstalowane za pomocą menadżera pakietów \textit{npm} \cite{npm}. W projekcie zostały użyte następujące narzędzia:
\begin{enumerate}
    \item \textit{ESLint} \cite{ESLint} - narzędzie, które pomaga w utrzymaniu spójności kodu, dzięki czemu można łatwo go czytać i utrzymywać. W projekcie zostały użyte reguły, które zostały zdefiniowane przez twórców React \cite{React}. Dodatkowo zostały dodane reguły, które sortują importy oraz sprawdzają, czy zostały użyte. Konfiguracja została umieszczona w pliku \textit{.eslintrc}.
    \item \textit{Prettier} \cite{Prettier} - narzędzie, które służy do formatowania kodu. W projekcie zostały użyte reguły, które zostały zdefiniowane przez twórców Prettier \cite{Prettier}. Konfiguracja została umieszczona w pliku \textit{.prettierrc}.
    \item \textit{Vite} \cite{vite} - narzędzie, które służy do budowania aplikacji. W projekcie zostały użyte reguły, które zostały zdefiniowane przez twórców Vite \cite{vite}. Konfiguracja została umieszczona w pliku \textit{vite.config.ts}.
    \item \textit{pre-commit} \cite{pre_commit} - narzędzie, które służy do automatyzacji procesu commitowania kodu. W projekcie zostały użyte reguły, które zostały zdefiniowane przez twórców pre-commit \cite{pre_commit}. Konfiguracja została umieszczona w pliku \textit{package.json}.
\end{enumerate}

\subsection{Zastosowane techniki pozyskiwania informacji}
W projekcie ze względu na powody, które zostały opisane w rozdziale \ref{data_sources}, jedynym źródłem informacji o telefonach komórkowych jest API GSM Areny. API zostało stworzenie w oparciu o metodę web scrapingu. Metoda ta pozwala, na pozyskanie informacji, ze strony internetowej. Dzięki udostępnieniu kodu źródłowego nieoficjalnego GSM Arena API \cite{gsm_arena_api}, możemy zauważyć, że została tam użyty web scraping.

Web scraping \cite{web_scraping} jest to metoda automatyzująca, polegająca na pobieraniu dokumentów HTML \ref{HTML} z serwisów internetowych w celu pozyskania danych z dokumentu. Metoda ta zawiera dwa moduły: przeszukiwarkę (ang. \textit{crawler}) oraz tzw. skrobaczkę (ang. \textit{scraper}).

Przeszukiwarka jest to algorytm, który w sposób automatyczny przeszukuje stronę w celu pozyskania informacji. W naszym przypadku, poszukujemy informacji o cenie danego telefonu, pozyskujemy także dzięki temu specyfikację ze stron GSM Areny \cite{gsm_arena}. W ten sposób możemy pozyskać informację, ze stron, które nie udostępniają swoich serwisów, do użytku publicznego. Następnie dane z przeszukiwarki są przekazywane do skrobaczki, która wyciąga z nich interesujące nas informacje.

Skrobaczka jest to algorytm, który potrafi konwertować dane z postaci znaczników HTML \ref{HTML}, do postaci bardziej przyjaznej dla programisty. Można również rozszerzyć te dane o atrybuty znajdujące się w znacznikach. Tak zostały rozszerzone dane, dotyczące cen, poprzez dodanie hiperłączy do sklepów, gdzie można dane urządzenie kupić. W naszym przypadku, skrobaczka konwertuje dane z postaci znaczników HTML \ref{HTML}, do postaci JSON \ref{JSON}.
